package com.patrick.inventorymanagementtask.api.utils;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;
import com.patrick.inventorymanagementtask.properties.ApplicationMessages;
import com.patrick.inventorymanagementtask.utils.ResponseModel;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @author patrick on 4/8/20
 * @project  inventory
 */
public class ApiAbstractController {
    @Value("${base.url}")
    protected String baseURL;

    @Autowired
    @Qualifier("loggerService")
    protected LoggerInterface loggerService;

    /**
     * Get the Jackson object mapper used to read and write json
     *
     * @return  ObjectMapper
     */
    protected final ObjectMapper getObjectMapper() {
        // The object mapper
        ObjectMapper mapper = new ObjectMapper();
        DefaultSerializerProvider sp = new DefaultSerializerProvider.Impl();

        // Use the custom serialiser for null items
        sp.setNullValueSerializer(new NullSerializer());
        mapper.setSerializerProvider(sp);

        // To prevent errors on empty beans
        mapper.disable( SerializationFeature.FAIL_ON_EMPTY_BEANS );

        // Return the mapper
        return mapper;
    }

    /**
     * Remove user login details from the api logger
     *
     * @param   request
     * @param   field
     * @return  ObjectNode
     */
    protected ObjectNode filterRequest(JsonNode request, String field) {
        ObjectNode root = (new ObjectMapper()).createObjectNode();
        if ( null == request ) return root;

        Iterator<String> cols = request.fieldNames();
        String col;

        while ( cols.hasNext() ) {
            col = cols.next();
            if ( field.equals(col) ) continue;

            if( col.contains("password")) continue;

            root.set(col, request.get(col));
        }

        return root;
    }

    /**
     * Called to render the response as generated by the class item
     *
     * @param   url
     * @param   request
     * @param   response
     * @return  ModelAndView
     */
    protected ResponseModel apiLogger(String url, ObjectNode request, ResponseModel response) {
        // The object mapper
        ObjectMapper mapper = getObjectMapper();

        // Get the json string
        String json = "";
        try {
            // Get the response
            json = mapper.writeValueAsString(response);

            // Prepare the items to log
            StringBuilder messageLog = new StringBuilder();

            messageLog.append("URL: ").append(url).append("\n");
            messageLog.append("Request: ").append((null == request) ? "": request.toString()).append("\n\n");
            messageLog.append("Response: ").append(json).append("\n");

            // Log the message
            loggerService.info(messageLog.toString());
        }
        catch (Exception e) {
            loggerService.logStackTrace(e);
        }

        return response;
    }

    /**
     * Called to log the error that has occurred and display the response to the
     * app
     *
     * @param   url
     * @param   request
     * @param   ex
     * @return  ModelAndView
     */
    protected ResponseModel apiError(String url, ObjectNode request, Exception ex) {
        // The object mapper
        ObjectMapper mapper = getObjectMapper();
      ResponseModel response= new ResponseModel();

        // Get the json string
        String json = "";
        try {
            // Get the response
//            response = failedRequest (
//                "An error occured while processing your request.",
//                "EE", new HashMap<String, Object>()
//            );
            response.setStatus("500");
            response.setMessage(ApplicationMessages.get("response.error.general"));
            json = mapper.writeValueAsString( response );

            // Prepare the items to log
            StringBuilder messageLog = new StringBuilder();

            messageLog.append("URL: ").append(url).append("\n");
            messageLog.append("Request: ").append((null == request) ? "": request.toString()).append("\n\n");
            messageLog.append("Response: ").append(json).append("\n\n");
            messageLog.append("Error: ").append(ex.toString()).append("\n");

            // Log the message
            loggerService.logStackTrace(ex, messageLog);
        }
        catch (Exception e) {
            loggerService.logStackTrace(e);
        }


        return response;
    }

    /**
     * Called to get the current timestamp as a string value
     *
     * @return  String
     */
    protected String getDateStamp() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return sdf.format(new Date(System.currentTimeMillis()));
    }

    /**
     * Called to get the error response when the process fails
     *
     * @param   message
     * @param   status
     * @return  Map<String, Object>
     */
    protected Map<String, Object> failedRequest(String message, String status) {
        return failedRequest(message, status, new HashMap<String, Object>());
    }

    /**
     * Called to get the error response when the process fails
     *
     * @param   message
     * @param   status
     * @param   data
     * @return  Map<String, Object>
     */
    protected Map<String, Object> failedRequest(String message, String status, Map<String, Object> data) {
        Map<String, Object> map = new HashMap<>();

        // Show that the process did not end well
        Map<String, Object> msg = new HashMap<>();
        map.put("message", message);

        // Set the other additional information
        map.put("status", status);

        // When there is more data to place
        if ( null != data && !data.isEmpty() ) map.put("data", data);

        // Return the response
        return map;
    }
}
